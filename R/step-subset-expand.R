#' Expand data frame to include all possible combinations of values.
#'
#' @description
#' This is a method for the tidyr `expand()` generic. It is translated to
#' [data.table::CJ()].
#'
#' @param data A [lazy_dt()].
#' @inheritParams tidyr::expand
#' @examples
#' library(tidyr)
#'
#' fruits <- lazy_dt(tibble(
#'   type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
#'   year   = c(2010, 2010, 2012, 2010, 2010, 2012),
#'   size  =  factor(
#'     c("XS", "S",  "M", "S", "S", "M"),
#'     levels = c("XS", "S", "M", "L")
#'   ),
#'   weights = rnorm(6, as.numeric(size) + 2)
#' ))
#'
#' # All possible combinations ---------------------------------------
#' # Note that all defined, but not necessarily present, levels of the
#' # factor variable `size` are retained.
#' fruits %>% expand(type)
#' fruits %>% expand(type, size)
#' fruits %>% expand(type, size, year)
#'
#' # Other uses -------------------------------------------------------
#' fruits %>% expand(type, size, 2010:2012)
#'
#' # Use `anti_join()` to determine which observations are missing
#' all <- fruits %>% expand(type, size, year)
#' all
#' all %>% dplyr::anti_join(fruits)
#'
#' # Use with `right_join()` to fill in missing rows
#' fruits %>% dplyr::right_join(all)
# exported onLoad
expand.dtplyr_step <- function(data, ..., .name_repair = "check_unique") {
  dots <- prepare_expand_dots(data, ..., .name_repair = .name_repair)

  # TODO handle factors
  if (length(dots) == 0) {
    return(data)
  }

  tbl_list <- c(
    list(expand_no_nesting(data, dots$simple)),
    expand_nesting(data, dots$nesting)
  )

  out <- Reduce(function(x, y) left_join(x, y, by = group_vars(data)), tbl_list)

  renamed <- names(dots$select) != unname(dots$select)
  relocated <- unname(dots$select) != out$vars
  if (any(renamed) || any(relocated)) {
    out <- select(out, !!!dots$select)
  }

  out
}

# exported onLoad
expand.data.table <- function(data, ..., .name_repair = "check_unique") {
  data <- lazy_dt(data)
  tidyr::expand(data, ..., .name_repair = .name_repair)
}

prepare_expand_dots <- function(data, ..., .name_repair) {
  dots <- capture_dots(data, ..., .j = FALSE)

  dot_is_null <- vapply(dots, is_null, logical(1))
  dots <- dots[!dot_is_null]
  dot_names_tidyr <- names(exprs(..., .named = TRUE))[!dot_is_null]
  if (is_null(dots)) {
    return(NULL)
  }

  is_nesting <- vapply(dots, function(x) is_call(x, "nesting"), logical(1))
  dots_df <- tibble::tibble(
    expr = dots,
    position = seq_along(dots)
  )

  dots_df_nesting <- dots_df[is_nesting, ]
  nesting_vars <- lapply(dots_df_nesting$expr, get_nesting_vars)
  dots_df_nesting$name_tidyr <- lapply(nesting_vars, names)
  dots_df_nesting$var <- lapply(nesting_vars, unlist)

  dots_df_simple <- dots_df[!is_nesting, ]
  simple_vars <- dt_dot_names(dots_df_simple$expr)
  dots_df_simple$name_dt <- names(simple_vars)
  dots_df_simple$var <- simple_vars
  dots_df_simple$name_tidyr <- dot_names_tidyr[!is_nesting]

  meta_df <- dplyr::bind_rows(
    dots_df_simple,
    tidyr::unnest(dots_df_nesting, "name_tidyr")
  )
  groups <- group_vars(data)
  names_dt <- c(groups, dplyr::coalesce(meta_df$name_dt, meta_df$name_tidyr))
  names_tidyr <- vctrs::vec_as_names(
    c(groups, meta_df$name_tidyr),
    repair = .name_repair
  )
  order <- c(seq_along(groups), length(groups) + order(meta_df$position))

  list(
    simple = dots_df_simple$var,
    nesting = dots_df_nesting$var,
    select = set_names(names_dt, names_tidyr)[order]
  )
}

get_nesting_vars <- function(expr) {
  args <- call_args(expr)

  repair <- args[[".name_repair"]] %||% "check_unique"
  args[[".name_repair"]] <- NULL

  vars <- exprs_auto_name(args)
  nms <- vctrs::vec_as_names(names(vars), repair = repair)
  set_names(vars, nms)
}

expand_nesting <- function(data, vars) {
  if (is_empty(vars)) {
    return(NULL)
  }

  lapply(vars, function(x) distinct(data, !!!x))
}

dt_dot_names <- function(dots, .name_repair) {
  named_dots <- have_name(dots)
  if (any(!named_dots)) {
    # Auto-names generated by enquos() don't always work with the CJ() step
      ## Ex: `1:3`
    # Replicates the "V" naming convention data.table uses
    symbol_dots <- vapply(dots, is_symbol, logical(1))
    needs_v_name <- !symbol_dots & !named_dots
    v_names <- paste0("V", 1:length(dots))
    names(dots)[needs_v_name] <- v_names[needs_v_name]
    names(dots)[symbol_dots] <- lapply(dots[symbol_dots], as_name)
  }
  dots
}

expand_no_nesting <- function(data, dots, .name_repair) {
  if (length(data$groups) == 0) {
    dt_vars <- names(dots)

    dt_auto_names <- names(dt_dot_names(unname(dots)))
    name_needed <- dt_auto_names != dt_vars
    names(dots)[!name_needed] <- ""

    out <- step_subset_j(
      parent = data,
      vars = dt_vars,
      j = expr(CJ(!!!dots, unique = TRUE))
    )
  } else {
    out <- distinct(data, !!!syms(data$groups), !!!dots)

    on <- names(dots)
    cj <- expr(CJ(!!!syms(on), unique = TRUE))

    on <- call2(".", !!!syms(on))
    out <- step_subset(out, j = expr(.SD[!!cj, on = !!on]))
  }

  out
}
